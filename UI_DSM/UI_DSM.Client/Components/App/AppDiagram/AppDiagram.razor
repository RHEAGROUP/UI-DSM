<!--------------------------------------------------------------------------------------------------------
// AppDiagram.razor
// Copyright (c) 2022 RHEA System S.A.
//
// Author: Antoine Théate, Sam Gerené, Alex Vorobiev, Alexander van Delft, Martin Risseeuw
//
// This file is part of UI-DSM.
// The UI-DSM web application is used to review an ECSS-E-TM-10-25 model.
//
// The UI-DSM application is provided to the community under the Apache License 2.0.
-------------------------------------------------------------------------------------------------------->

@namespace AppComponents
@using Blazor.Diagrams.Core
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Models

<!-- required to resolve DiagramCanvas component -->
@using Blazor.Diagrams.Components
@using UI_DSM.Client.Pages.Administration
@using UI_DSM.Client.Utilities

<div class="app-diagram">
  <div class="diagram-container">
    <CascadingValue Value="Diagram">
      <DiagramCanvas>
        <Widgets>
            <NavigatorWidget Width="200" Height="150" DefaultStyle="true"></NavigatorWidget>
        </Widgets>
      </DiagramCanvas>
    </CascadingValue>
  </div>
</div>

@code {
  private Diagram Diagram { get; set; }

  protected override void OnInitialized()
  {
    base.OnInitialized();

    var options = new DiagramOptions
    {
      DeleteKey = "Delete", // What key deletes the selected nodes/links
      Links = new DiagramLinkOptions
      {
        DefaultRouter = Routers.Orthogonal,
        DefaultPathGenerator = PathGenerators.Straight
      },
      Zoom = new DiagramZoomOptions
      {
        Minimum = 0.5, // Minimum zoom value
        Inverse = false, // Whether to inverse the direction of the zoom when using the wheel
      }
    };

    Diagram = new Diagram(options);

    Setup();
    Diagram.ReconnectLinksToClosestPorts();
  }

  private void Setup()
  {
	  var nodeWidth = 150;
	  var nodeSpacing = 50;
	  var requirementsSpecification = RequirementsSpecificationMockData.GetRequirementsSpecification();
	  var requirementsGroupWidth = requirementsSpecification.Group.Count * (nodeWidth+nodeSpacing);
	  var requirementsSpecificationNode = NewNode(requirementsGroupWidth/2, 50);
	  requirementsSpecificationNode.Title = requirementsSpecification.Name;
      this.Diagram.Nodes.Add(requirementsSpecificationNode);

	  var startingGroupX = 50;
	  var startingRequirementX = 0;
	  foreach (var group in requirementsSpecification.Group)
	  {
		/*var nodeGroup = NewNode(startingGroupX, 150);
		  nodeGroup.Title = group.Name;
		  this.Diagram.Nodes.Add(nodeGroup);
		  var link = new LinkModel(requirementsSpecificationNode.GetPort(PortAlignment.Bottom), nodeGroup.GetPort(PortAlignment.Top));
          this.Diagram.Links.Add(link);*/
		  var groupNodes = new List<NodeModel>();

		  var requirements = requirementsSpecification.Requirement.Where(x => x.Group.Iid == group.Iid).ToList();
		  foreach (var requirement in requirements)
		  {
			  var requirementNode = NewNode(startingRequirementX, 250);
                requirementNode.Title = requirement.Name;
              this.Diagram.Nodes.Add(requirementNode);
                groupNodes.Add(requirementNode);
               
			  startingRequirementX += 250;
		  }

		  var groupModel = new GroupModel(groupNodes)
		  {
			  Title = group.Name
		  };

		  groupModel.AddPort(PortAlignment.Bottom);
		  groupModel.AddPort(PortAlignment.Top);
		  var requirementLink = new LinkModel(requirementsSpecificationNode.GetPort(PortAlignment.Bottom), groupModel.GetPort(PortAlignment.Top));
		  this.Diagram.Links.Add(requirementLink);

		  this.Diagram.AddGroup(groupModel);
		  startingGroupX += 150;
	  }
  }

  private static NodeModel NewNode(double x, double y)
  {
    var node = new NodeModel(new Point(x, y));
    node.AddPort(PortAlignment.Bottom);
    node.AddPort(PortAlignment.Top);
    node.AddPort(PortAlignment.Left);
    node.AddPort(PortAlignment.Right);
   // node.Locked = true;
    return node;
  }
}