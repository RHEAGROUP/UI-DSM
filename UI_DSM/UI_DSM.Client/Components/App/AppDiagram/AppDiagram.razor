<!--------------------------------------------------------------------------------------------------------
// AppDiagram.razor
// Copyright (c) 2022 RHEA System S.A.
//
// Author: Antoine Théate, Sam Gerené, Alex Vorobiev, Alexander van Delft, Martin Risseeuw
//
// This file is part of UI-DSM.
// The UI-DSM web application is used to review an ECSS-E-TM-10-25 model.
//
// The UI-DSM application is provided to the community under the Apache License 2.0.
-------------------------------------------------------------------------------------------------------->

@namespace AppComponents
@using Blazor.Diagrams.Core
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Models

<!-- required to resolve DiagramCanvas component -->
@using Blazor.Diagrams.Components
@using UI_DSM.Client.Pages.Administration
@using UI_DSM.Client.Utilities

<div class="app-diagram">
  <div class="diagram-container">
    <CascadingValue Value="Diagram">
      <DiagramCanvas>
        <Widgets>
          <NavigatorWidget Width="200" Height="150" DefaultStyle="true"></NavigatorWidget>
        </Widgets>
      </DiagramCanvas>
    </CascadingValue>
  </div>
</div>

@code {
  private Diagram Diagram { get; set; }

  protected override void OnInitialized()
  {
    base.OnInitialized();

    var options = new DiagramOptions
    {
      Links = new DiagramLinkOptions
      {
        DefaultRouter = Routers.Orthogonal,
        DefaultPathGenerator = PathGenerators.Straight
      },
      Zoom = new DiagramZoomOptions
      {
        Minimum = 0.5, // Minimum zoom value
        Inverse = false, // Whether to inverse the direction of the zoom when using the wheel
      }
    };

    Diagram = new Diagram(options);

    Setup();
    Diagram.ReconnectLinksToClosestPorts();
  }

  private void Setup()
  {
    var nodeWidth = 150;
    var nodeSpacing = 25;
    var requirementsSpecification = RequirementsSpecificationMockData.GetRequirementsSpecification();

    // We should multiply this by the amount of groups I guess?
    var requirementsGroupWidth = requirementsSpecification.Group.Count * (nodeWidth + nodeSpacing);
    
    var requirementsSpecificationNode = NewNode(requirementsGroupWidth / 2, 50);
    requirementsSpecificationNode.Title = requirementsSpecification.Name;
    this.Diagram.Nodes.Add(requirementsSpecificationNode);

    var startingGroupX = 0;
    var groupIndex = 0;

    var startingRequirementX = 0;
    var requirementIndex = 0;
    var startingRequirementY = 300;


    foreach (var group in requirementsSpecification.Group)
    {
      /*var nodeGroup = NewNode(startingGroupX, 150);
      nodeGroup.Title = group.Name;
      this.Diagram.Nodes.Add(nodeGroup);
      var link = new LinkModel(requirementsSpecificationNode.GetPort(PortAlignment.Bottom),
      nodeGroup.GetPort(PortAlignment.Top));
      this.Diagram.Links.Add(link);*/
      var groupNodes = new List<NodeModel>();
      var requirements = requirementsSpecification.Requirement.Where(x => x.Group.Iid == group.Iid).ToList();

      foreach (var requirement in requirements)
      {

        var requirementNode = NewNode(startingRequirementX, startingRequirementY);
        requirementNode.Title = requirement.Name;
        this.Diagram.Nodes.Add(requirementNode);
        groupNodes.Add(requirementNode);

        startingRequirementX += nodeWidth + nodeSpacing;
        requirementIndex++;


        // We should also add a reset on new group
        if (requirementIndex % 4 == 0)
        {
          startingRequirementX = startingGroupX;
          startingRequirementY += 150;
        }
      }

      var groupModel = new GroupModel(groupNodes)
      {
        Title = group.Name
      };

      groupModel.AddPort(PortAlignment.Bottom);
      groupModel.AddPort(PortAlignment.Top);
      var requirementLink = new LinkModel(requirementsSpecificationNode.GetPort(PortAlignment.Bottom),
      groupModel.GetPort(PortAlignment.Top));
      this.Diagram.Links.Add(requirementLink);
      this.Diagram.AddGroup(groupModel);

      var groupWidth = requirements.Count * (nodeWidth + nodeSpacing) + 50;

      if (groupWidth > 700)
      {
        groupWidth = 750;
      }

      startingGroupX += groupWidth;
      startingRequirementY = 300;

      startingRequirementX = startingGroupX;
      requirementIndex = 0;
      groupIndex++;

    }
  }

  private static NodeModel NewNode(double x, double y)
  {
    var node = new NodeModel(new Point(x, y));
    node.AddPort(PortAlignment.Bottom);
    node.AddPort(PortAlignment.Top);
    node.AddPort(PortAlignment.Left);
    node.AddPort(PortAlignment.Right);
    // node.Locked = true;
    return node;
  }
}